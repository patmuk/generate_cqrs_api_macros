## Overview
This macro generates code for handling the state of an application composed of several models.

The model state altering funtions are interpreted in a CQRS style.
By using locks on the model the state can be altered concurrently.

This macro is made to work with Flutter-Rust-Bridge, so that the UI can be implemented in Flutter,
while the logic and state is handled in Rust. However, this is not a strickt requirement.
The FRB generated `RustAutoOpaque`  type is in essence a `RWLock`. 

## How to apply the macro
Add this macro as an attriute to your struct, which implements the `Lifecycle` trait, generated by this macro.
(This sounds like a hen-and-egg problem, but it resolves automatically.)

### traits
The macro generates some (more) traits, which need to be implemented by you.
These traits are not generated, but copies of the sourceCode in `generate_cqrs_api_macro_impl/src/generating/traits`.
- Lifecycle - as the general API interface, to be consumed by other apps
- AppConfig - structure to hold the apps configuration, like the path to the persisting file
- AppState - logic to handle the app's state

Each of your model implementations need to implement these traits
- CQRSModel - marker so that the code generation recognizes your model
- CQRSModelLock - marker so that the lock to the model is recognized

The used traits are generated from static files in `generate_cqrs_api_macro_impl/src/generating/traits`.
This makes them available in the `impl Lifecycle` for the rest of the using codebase. 

#### implement your models
Each model needs to be composed of two parts:
1. a struct holding the model's data (`impl CQRSModel`) and
2. a struct implementing the model's functions and holding a lock to the model (`impl CQRSModelLock`).


#### implement functions on your model
The functions, which either manipulate the model's state (CQRS commands) or return the model's value(s) (CQRS queries) are implemented in your `CQRSModelLock`.

They are recognized for code generation by their signature:

`-> Result<Vec<Effect>, ProcessingError>` for CQRS queries and
`-> Result<(bool, Vec<Effect>), ProcessingError>` for CQRS commands.

In the implementation access the model via the lock, which is your `Self` object.
Use either `.blocking_read()` for read-only access or `blocking_write()` for write-only access.
In harmonie with rust borrowing concept, there can be multiple reads but only a single write.
Calling this function blocks the control flow until the lock is aquired.

Now you can manipulate the aquired model.

##### Implementing Errors
Any possible Error should be defined in an `enum Error` and can be returned from your cqrs function.

##### Implementing Effects
Following the event driven philosophy any function leads to an Effect, which is a message to the calling app to do something.
This can be anything, typically it is asking the calling app to render some values.
Define possible effects f manipulations on your model in an `enum Effect`.
While CQRS queries don't alter a model's state, they can have an effect on the calling app.
And one CQRS functon can have multiple effects.

Thus, we return `Vec<Effect>`.

##### Return model values
There is two ways to return a model's values: 1. returning the value directly or 2. returning the whole model.

If the value is not heavy it can be returned directly. For this, implement an `enum Effect` variant, that can hold your value, like `RenderText(String)`.
This value has to be `clone()`ed.

Alternatively you can return the whole model - or more preceise the lock on the value: Have an `enum Effect` variant, which holds the model's lock, like `RenderModel(ModelLock)`.
Again, you need to `clone()` the lock - but this is very lightweight (depending on the nature of your consuming app. If it is a Rust app or a flutter app, connected by FRB, it is only copying a pointer).
Now the calling app can aquire the lock on the model and read the needed values.
However, do not write on the model, as this would not be detected by the state management!
Therefore, keep the model's fields private and expose them only via getters (in addition to the CQRS Queries).

## Traits
